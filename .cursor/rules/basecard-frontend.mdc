---
alwaysApply: true
description: BaseCard Next.js Frontend Development Rules
---

# BaseCard Next.js Frontend Development Rules

This project is a **BaseCard NFT Mini App** built with Next.js 15, TypeScript, Tailwind CSS, and Web3 technologies. Follow these rules for consistent, maintainable code.

## Project Architecture

### Tech Stack

- **Framework**: Next.js 15 (App Router)
- **Language**: TypeScript
- **Styling**: Tailwind CSS 4.x
- **State Management**: Jotai + TanStack Query
- **Web3**: Coinbase OnchainKit, Wagmi, Viem
- **Database**: Drizzle ORM + PostgreSQL (Supabase)
- **UI Components**: Radix UI + shadcn/ui

### Directory Structure

```
app/                    # Next.js App Router pages
├── (main)/            # Main layout group
├── api/               # API routes
├── collection/        # Collection page
├── earn/              # Earn page
├── mycard/            # My Card page
└── success/           # Success page

components/            # Reusable components
├── common/            # Common utilities
├── layouts/           # Layout components
├── main/              # Main feature components
├── token/             # Token-related components
└── ui/                # Base UI components (shadcn)

hooks/                 # Custom React hooks
lib/                   # Utilities and configurations
store/                 # Jotai state management
db/                    # Database schema and seeds
```

## Code Quality Rules

### 1. Naming Conventions

**Rule**: Use descriptive, unambiguous names that clearly indicate purpose.

```typescript
// ✅ Good - Clear purpose
const ANIMATION_DELAY_MS = 300;
const MAX_CARD_SKILLS = 5;

// ❌ Bad - Magic numbers
await delay(300);
if (skills.length > 5) return;

// ✅ Good - Descriptive function names
async function fetchUserCardByAddress(address: string) {}
const useBaseCardNFTs = () => {};

// ❌ Bad - Ambiguous names
async function getData(id: string) {}
const useData = () => {};
```

### 2. Component Organization

**Rule**: Organize components by feature/domain, not just by type.

```typescript
// ✅ Good - Feature-based organization
components/
├── card/
│   ├── CardProfile.tsx
│   ├── CardSkills.tsx
│   └── CardActions.tsx
├── program/
│   ├── ProgramList.tsx
│   └── ProgramCard.tsx
└── collection/
    ├── CollectionGrid.tsx
    └── CollectionItem.tsx

// ❌ Bad - Type-based only
components/
├── buttons/
├── modals/
└── forms/
```

### 3. State Management Patterns

**Rule**: Use focused, single-purpose hooks and atoms.

```typescript
// ✅ Good - Focused state management
// store/nftstate.ts
export const nftState = atom({
  ownedCards: [] as Card[],
  isLoading: false,
});

// hooks/useBaseCardNFTs.ts
export function useBaseCardNFTs() {
  const [nftData, setNftData] = useAtom(nftState);
  // Only NFT-related logic
}

// ❌ Bad - Broad state management
export const globalState = atom({
  user: null,
  nfts: [],
  programs: [],
  collections: [],
  ui: {},
  // Too many unrelated concerns
});
```

### 4. API Integration

**Rule**: Use consistent patterns for API calls with proper error handling.

```typescript
// ✅ Good - Consistent API patterns
export function useCards() {
  return useQuery({
    queryKey: ["cards"],
    queryFn: fetchCards,
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
}

export function useCardByAddress(address: string) {
  return useQuery({
    queryKey: ["card", address],
    queryFn: () => fetchCardByAddress(address),
    enabled: !!address,
  });
}

// ✅ Good - Validation result pattern
type ValidationResult = { ok: true; data: Card } | { ok: false; error: string };

function validateCardData(data: unknown): ValidationResult {
  if (!data || typeof data !== "object") {
    return { ok: false, error: "Invalid card data" };
  }
  return { ok: true, data: data as Card };
}
```

### 5. Component Composition

**Rule**: Use composition over props drilling and separate concerns clearly.

```typescript
// ✅ Good - Composition pattern
function CardProfile({ cardId }: { cardId: string }) {
  return (
    <CardContainer>
      <CardHeader>
        <CardImage cardId={cardId} />
        <CardActions cardId={cardId} />
      </CardHeader>
      <CardContent>
        <CardSkills cardId={cardId} />
        <CardBio cardId={cardId} />
      </CardContent>
    </CardContainer>
  );
}

// ✅ Good - Separated conditional rendering
function SubmitButton({ userRole }: { userRole: string }) {
  return userRole === "viewer" ? <ViewerSubmitButton /> : <AdminSubmitButton />;
}
```

### 6. Form Handling

**Rule**: Use appropriate form cohesion based on requirements.

```typescript
// ✅ Good - Field-level validation for independent fields
function CardMintForm() {
  const {
    register,
    formState: { errors },
  } = useForm();

  return (
    <form>
      <input
        {...register("nickname", {
          validate: (value) =>
            value.trim() === "" ? "Nickname required" : true,
        })}
      />
      {errors.nickname && <span>{errors.nickname.message}</span>}
    </form>
  );
}

// ✅ Good - Form-level validation for related fields
const cardSchema = z.object({
  nickname: z.string().min(1, "Nickname required"),
  bio: z.string().max(500, "Bio too long"),
  skills: z.array(z.string()).max(5, "Max 5 skills"),
});
```

### 7. Web3 Integration

**Rule**: Abstract Web3 complexity into dedicated hooks and services.

```typescript
// ✅ Good - Web3 abstraction
export function useWalletConnection() {
  const { address, isConnected } = useAccount();
  const { connect } = useConnect();
  const { disconnect } = useDisconnect();

  return {
    address,
    isConnected,
    connect,
    disconnect,
  };
}

// ✅ Good - Contract interaction abstraction
export function useCardMint() {
  const { writeContract } = useWriteContract();

  const mintCard = useCallback(
    async (cardData: CardData) => {
      try {
        await writeContract({
          address: BASECARD_CONTRACT_ADDRESS,
          abi: BaseCardABI,
          functionName: "mint",
          args: [cardData.nickname, cardData.bio, cardData.imageURI],
        });
      } catch (error) {
        console.error("Mint failed:", error);
        throw error;
      }
    },
    [writeContract]
  );

  return { mintCard };
}
```

### 8. Error Handling

**Rule**: Implement consistent error handling patterns.

```typescript
// ✅ Good - Error boundary for components
function CardErrorBoundary({ children }: { children: React.ReactNode }) {
  return (
    <ErrorBoundary
      fallback={<CardErrorFallback />}
      onError={(error) => console.error("Card error:", error)}
    >
      {children}
    </ErrorBoundary>
  );
}

// ✅ Good - API error handling
export function useCardMutation() {
  return useMutation({
    mutationFn: createCard,
    onError: (error) => {
      console.error("Card creation failed:", error);
      toast.error("Failed to create card");
    },
    onSuccess: () => {
      toast.success("Card created successfully");
    },
  });
}
```

### 9. Performance Optimization

**Rule**: Optimize for performance with proper memoization and lazy loading.

```typescript
// ✅ Good - Memoized components
const CardItem = memo(({ card }: { card: Card }) => {
  return (
    <div className="card-item">
      <CardImage src={card.imageURI} alt={card.nickname} />
      <CardContent card={card} />
    </div>
  );
});

// ✅ Good - Lazy loading for heavy components
const CardSharePopup = lazy(() => import("./CardSharePopup"));

// ✅ Good - Optimized queries
export function useCards() {
  return useQuery({
    queryKey: ["cards"],
    queryFn: fetchCards,
    staleTime: 5 * 60 * 1000,
    gcTime: 10 * 60 * 1000,
  });
}
```

### 10. Testing Patterns

**Rule**: Write testable code with clear separation of concerns.

```typescript
// ✅ Good - Testable components
function CardProfile({ card, onEdit }: CardProfileProps) {
  const handleEdit = useCallback(() => {
    onEdit?.(card.id);
  }, [card.id, onEdit]);

  return (
    <div data-testid="card-profile">
      <h2>{card.nickname}</h2>
      <p>{card.bio}</p>
      <button onClick={handleEdit}>Edit</button>
    </div>
  );
}

// ✅ Good - Testable hooks
export function useCardValidation() {
  const validateCard = useCallback((card: Card) => {
    const errors: string[] = [];
    if (!card.nickname.trim()) errors.push("Nickname required");
    if (card.skills.length > 5) errors.push("Max 5 skills allowed");
    return errors;
  }, []);

  return { validateCard };
}
```

## File Organization Rules

### API Routes

- Place in `app/api/` directory
- Use descriptive route names
- Implement proper error handling
- Follow RESTful conventions

### Components

- Group by feature/domain
- Use PascalCase for component names
- Export from index files when appropriate
- Keep components focused and single-purpose

### Hooks

- Place in `hooks/` directory
- Use `use` prefix
- Return consistent data structures
- Handle loading and error states

### Utilities

- Place in `lib/` directory
- Use descriptive function names
- Export from index files
- Keep functions pure when possible

## Database Rules

### Schema Design

- Use Drizzle ORM for type safety
- Define clear relationships
- Use appropriate data types
- Add proper constraints

### Seed Data

- Use realistic test data
- Maintain data consistency
- Include edge cases
- Document data relationships

## Web3 Integration Rules

### Contract Interaction

- Abstract contract calls into hooks
- Handle transaction states properly
- Implement proper error handling
- Use type-safe ABI definitions

### State Management

- Use Jotai for Web3 state
- Separate Web3 state from UI state
- Implement proper loading states
- Handle connection/disconnection

## Styling Rules

### Tailwind CSS

- Use utility classes consistently
- Create component variants with CVA
- Use CSS variables for theming
- Follow mobile-first approach

### Component Styling

- Use shadcn/ui components as base
- Extend with custom variants
- Maintain consistent spacing
- Use semantic color names

## Security Rules

### Input Validation

- Validate all user inputs
- Sanitize data before storage
- Use proper TypeScript types
- Implement client and server validation

### Web3 Security

- Validate contract interactions
- Handle wallet connection securely
- Implement proper error boundaries
- Use environment variables for sensitive data

## Performance Rules

### Optimization

- Use React.memo for expensive components
- Implement proper loading states
- Use lazy loading for heavy components
- Optimize images and assets

### Bundle Size

- Use dynamic imports for large dependencies
- Tree-shake unused code
- Optimize Web3 dependencies
- Monitor bundle size

## Documentation Rules

### Code Comments

- Document complex business logic
- Explain Web3 interactions
- Document API contracts
- Use JSDoc for functions

### README

- Keep project README updated
- Document setup instructions
- Include API documentation
- Document environment variables

## Git Workflow Rules

### Branching

- Use feature branches
- Follow conventional commits
- Keep commits atomic
- Write descriptive commit messages

### Code Review

- Review for security issues
- Check Web3 integration
- Verify error handling
- Ensure proper testing

---

**Remember**: These rules are guidelines to maintain code quality and consistency. Adapt them to specific project needs while maintaining the core principles of readability, predictability, cohesion, and low coupling.
