---
globs: app/api/**/*.ts
description: API route development standards for Next.js
---

# API Route Development Standards

## API Route Structure

### Route Handler Pattern

```typescript
// ✅ Good - Proper route handler structure
import { NextRequest, NextResponse } from "next/server";
import { z } from "zod";
import { db } from "@/lib/db";
import { cards } from "@/db/schema";

// Request validation schema
const CreateCardSchema = z.object({
  nickname: z.string().min(1).max(100),
  bio: z.string().max(500),
  imageURI: z.string().url(),
  address: z.string().length(42),
  skills: z.array(z.string()).max(5),
});

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const address = searchParams.get("address");

    if (address) {
      const card = await db.query.cards.findFirst({
        where: (cards, { eq }) => eq(cards.address, address),
      });

      if (!card) {
        return NextResponse.json({ error: "Card not found" }, { status: 404 });
      }

      return NextResponse.json(card);
    }

    const allCards = await db.query.cards.findMany();
    return NextResponse.json(allCards);
  } catch (error) {
    console.error("GET /api/cards error:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const validatedData = CreateCardSchema.parse(body);

    const [newCard] = await db.insert(cards).values(validatedData).returning();

    return NextResponse.json(newCard, { status: 201 });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: "Validation error", details: error.errors },
        { status: 400 }
      );
    }

    console.error("POST /api/cards error:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
```

### Error Handling Pattern

```typescript
// ✅ Good - Centralized error handling
class ApiError extends Error {
  constructor(
    message: string,
    public statusCode: number,
    public code?: string
  ) {
    super(message);
    this.name = "ApiError";
  }
}

function handleApiError(error: unknown): NextResponse {
  if (error instanceof ApiError) {
    return NextResponse.json(
      { error: error.message, code: error.code },
      { status: error.statusCode }
    );
  }

  if (error instanceof z.ZodError) {
    return NextResponse.json(
      { error: "Validation error", details: error.errors },
      { status: 400 }
    );
  }

  console.error("Unexpected error:", error);
  return NextResponse.json({ error: "Internal server error" }, { status: 500 });
}

// Usage in route handlers
export async function GET() {
  try {
    // API logic
  } catch (error) {
    return handleApiError(error);
  }
}
```

## Database Integration

### Drizzle ORM Patterns

```typescript
// ✅ Good - Type-safe database queries
import { db } from "@/lib/db";
import { cards, programs, collections } from "@/db/schema";
import { eq, and, desc } from "drizzle-orm";

export async function getCardByAddress(address: string) {
  const card = await db.query.cards.findFirst({
    where: (cards, { eq }) => eq(cards.address, address),
    with: {
      programs: true,
      collections: {
        with: {
          collectedCard: true,
        },
      },
    },
  });

  return card;
}

export async function createCard(cardData: CardCreateData) {
  const [newCard] = await db.insert(cards).values(cardData).returning();
  return newCard;
}

export async function updateCard(id: number, updates: CardUpdateData) {
  const [updatedCard] = await db
    .update(cards)
    .set(updates)
    .where(eq(cards.id, id))
    .returning();

  return updatedCard;
}
```

### Transaction Handling

```typescript
// ✅ Good - Database transactions
export async function createCardWithProgram(
  cardData: CardCreateData,
  programData: ProgramCreateData
) {
  return await db.transaction(async (tx) => {
    const [newCard] = await tx.insert(cards).values(cardData).returning();

    const [newProgram] = await tx
      .insert(programs)
      .values({
        ...programData,
        ownerCardId: newCard.id,
      })
      .returning();

    return { card: newCard, program: newProgram };
  });
}
```

## Validation Patterns

### Input Validation

```typescript
// ✅ Good - Comprehensive validation
import { z } from "zod";

const AddressSchema = z
  .string()
  .regex(/^0x[a-fA-F0-9]{40}$/, "Invalid Ethereum address format");

const CardCreateSchema = z.object({
  nickname: z
    .string()
    .min(1, "Nickname is required")
    .max(100, "Nickname too long"),
  bio: z.string().max(500, "Bio too long").optional(),
  imageURI: z.string().url("Invalid image URL").optional(),
  basename: z
    .string()
    .min(1, "Basename is required")
    .max(50, "Basename too long")
    .regex(
      /^[a-z0-9-]+$/,
      "Basename must contain only lowercase letters, numbers, and hyphens"
    ),
  role: z.string().max(100, "Role too long").optional(),
  skills: z
    .array(z.string())
    .max(5, "Maximum 5 skills allowed")
    .optional()
    .default([]),
  address: AddressSchema,
});

const CardUpdateSchema = CardCreateSchema.partial().omit({ address: true });

// Usage in route handlers
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const validatedData = CardCreateSchema.parse(body);
    // Process validated data
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        {
          error: "Validation failed",
          details: error.errors.map((e) => ({
            field: e.path.join("."),
            message: e.message,
          })),
        },
        { status: 400 }
      );
    }
    throw error;
  }
}
```

## Response Patterns

### Consistent Response Format

```typescript
// ✅ Good - Consistent API responses
interface ApiResponse<T = any> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
  meta?: {
    total?: number;
    page?: number;
    limit?: number;
  };
}

function createSuccessResponse<T>(data: T, message?: string): NextResponse {
  return NextResponse.json({
    success: true,
    data,
    message,
  } as ApiResponse<T>);
}

function createErrorResponse(
  error: string,
  statusCode: number = 400,
  details?: any
): NextResponse {
  return NextResponse.json(
    {
      success: false,
      error,
      details,
    } as ApiResponse,
    { status: statusCode }
  );
}

// Usage
export async function GET() {
  try {
    const cards = await getAllCards();
    return createSuccessResponse(cards, "Cards retrieved successfully");
  } catch (error) {
    return createErrorResponse("Failed to retrieve cards", 500);
  }
}
```

### Pagination

```typescript
// ✅ Good - Pagination implementation
interface PaginationParams {
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: "asc" | "desc";
}

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get("page") || "1");
  const limit = Math.min(parseInt(searchParams.get("limit") || "10"), 100);
  const sortBy = searchParams.get("sortBy") || "createdAt";
  const sortOrder = (searchParams.get("sortOrder") as "asc" | "desc") || "desc";

  const offset = (page - 1) * limit;

  const [cards, totalCount] = await Promise.all([
    db.query.cards.findMany({
      limit,
      offset,
      orderBy: (cards, { desc, asc }) =>
        sortOrder === "desc" ? desc(cards[sortBy]) : asc(cards[sortBy]),
    }),
    db.select({ count: sql<number>`count(*)` }).from(cards),
  ]);

  return NextResponse.json({
    success: true,
    data: cards,
    meta: {
      total: totalCount[0].count,
      page,
      limit,
      totalPages: Math.ceil(totalCount[0].count / limit),
    },
  });
}
```

## Security Patterns

### Input Sanitization

```typescript
// ✅ Good - Input sanitization
import DOMPurify from "isomorphic-dompurify";

function sanitizeInput(input: string): string {
  return DOMPurify.sanitize(input.trim());
}

export async function POST(request: NextRequest) {
  const body = await request.json();

  // Sanitize text inputs
  const sanitizedData = {
    ...body,
    nickname: sanitizeInput(body.nickname),
    bio: sanitizeInput(body.bio),
  };

  // Process sanitized data
}
```

### Rate Limiting

```typescript
// ✅ Good - Rate limiting implementation
import { Ratelimit } from "@upstash/ratelimit";
import { Redis } from "@upstash/redis";

const ratelimit = new Ratelimit({
  redis: Redis.fromEnv(),
  limiter: Ratelimit.slidingWindow(10, "1 m"), // 10 requests per minute
});

export async function POST(request: NextRequest) {
  const ip = request.ip ?? "127.0.0.1";
  const { success } = await ratelimit.limit(ip);

  if (!success) {
    return NextResponse.json({ error: "Rate limit exceeded" }, { status: 429 });
  }

  // Process request
}
```

## Web3 Integration

### Wallet Verification

```typescript
// ✅ Good - Wallet signature verification
import { verifyMessage } from "viem";

export async function POST(request: NextRequest) {
  const { address, signature, message } = await request.json();

  try {
    const isValid = await verifyMessage({
      address: address as `0x${string}`,
      message,
      signature: signature as `0x${string}`,
    });

    if (!isValid) {
      return NextResponse.json({ error: "Invalid signature" }, { status: 401 });
    }

    // Process authenticated request
  } catch (error) {
    return NextResponse.json(
      { error: "Signature verification failed" },
      { status: 401 }
    );
  }
}
```

## Testing Patterns

### API Route Testing

```typescript
// ✅ Good - Testable API routes
export async function GET(request: NextRequest) {
  try {
    const cards = await getCardsService();
    return NextResponse.json(cards);
  } catch (error) {
    return handleApiError(error);
  }
}

// Separate service for testability
export async function getCardsService() {
  return await db.query.cards.findMany();
}
```

### Mock Data for Testing

```typescript
// ✅ Good - Test data factories
export const createMockCard = (overrides: Partial<Card> = {}): Card => ({
  id: 1,
  nickname: "Test User",
  bio: "Test bio",
  imageURI: "https://example.com/image.jpg",
  basename: "testuser",
  role: "Developer",
  skills: ["TypeScript", "React"],
  address: "0x1234567890123456789012345678901234567890",
  ...overrides,
});
```

## Performance Optimization

### Caching

```typescript
// ✅ Good - Response caching
export async function GET() {
  const cacheKey = "cards:all";

  // Check cache first
  const cached = await redis.get(cacheKey);
  if (cached) {
    return NextResponse.json(JSON.parse(cached), {
      headers: {
        "Cache-Control": "public, max-age=300", // 5 minutes
      },
    });
  }

  // Fetch from database
  const cards = await db.query.cards.findMany();

  // Cache the result
  await redis.setex(cacheKey, 300, JSON.stringify(cards));

  return NextResponse.json(cards, {
    headers: {
      "Cache-Control": "public, max-age=300",
    },
  });
}
```

### Database Optimization

```typescript
// ✅ Good - Optimized queries
export async function getCardsWithRelations() {
  return await db.query.cards.findMany({
    with: {
      programs: {
        columns: {
          id: true,
          title: true,
          type: true,
        },
      },
      collections: {
        with: {
          collectedCard: {
            columns: {
              id: true,
              nickname: true,
              imageURI: true,
            },
          },
        },
      },
    },
  });
}
```

---

**Remember**: These API route standards ensure security, performance, and maintainability. Always validate inputs, handle errors gracefully, and use proper TypeScript types for better developer experience.
